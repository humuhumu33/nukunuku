"""
Buffer management with zero-copy operations.

Provides Pythonic wrapper around hologram-ffi buffers with:
- Zero-copy NumPy integration
- Automatic resource cleanup
- Type-safe operations
"""

from typing import TYPE_CHECKING, Optional
import numpy as np

if TYPE_CHECKING:
    from .executor import Executor

# Import hologram_ffi (generated by UniFFI)
try:
    import hologram_ffi as hg
except ImportError:
    raise ImportError(
        "hologram_ffi not found. Please ensure the hologram-ffi library is built and available. "
        "Run 'cargo build-ffi' in the hologram repository."
    )


class Buffer:
    """
    Memory buffer with zero-copy NumPy integration.

    Buffers are allocated by an Executor and provide efficient data transfer
    between Python/NumPy and hologram compute backend.

    Example:
        >>> exec = Executor()
        >>> buf = exec.allocate(1024)
        >>> data = np.random.randn(1024).astype(np.float32)
        >>> buf.from_numpy(data)  # Zero-copy transfer
        >>> result = buf.to_numpy()  # Zero-copy read

    Note:
        Buffers should be created via Executor.allocate(), not directly.
    """

    def __init__(self, executor: "Executor", handle: int, size: int, dtype=np.float32):
        """
        Initialize buffer (internal use only).

        Args:
            executor: Parent executor
            handle: FFI buffer handle
            size: Number of elements
            dtype: NumPy data type (default: np.float32)
        """
        self._executor = executor
        self._handle = handle
        self._size = size
        self._dtype = dtype
        self._element_size = np.dtype(dtype).itemsize
        self._freed = False

    @property
    def handle(self) -> int:
        """Get FFI handle."""
        return self._handle

    @property
    def size(self) -> int:
        """Get buffer size (number of elements)."""
        return self._size

    @property
    def dtype(self):
        """Get NumPy data type."""
        return self._dtype

    @property
    def nbytes(self) -> int:
        """Get buffer size in bytes."""
        return self._size * self._element_size

    def __len__(self) -> int:
        """Get buffer length (number of elements)."""
        return self._size

    def from_numpy(self, array: np.ndarray) -> None:
        """
        Copy data from NumPy array to buffer (zero-copy when possible).

        Args:
            array: NumPy array (must be contiguous float32)

        Raises:
            ValueError: If array shape or dtype doesn't match buffer
            RuntimeError: If buffer has been freed
        """
        if self._freed:
            raise RuntimeError("Buffer has been freed")

        # Validate array
        if not isinstance(array, np.ndarray):
            raise TypeError(f"Expected np.ndarray, got {type(array)}")

        if array.dtype != self._dtype:
            raise ValueError(
                f"Array dtype {array.dtype} doesn't match buffer dtype {self._dtype}"
            )

        if array.size != self._size:
            raise ValueError(
                f"Array size {array.size} doesn't match buffer size {self._size}"
            )

        # Ensure array is contiguous
        if not array.flags.c_contiguous:
            array = np.ascontiguousarray(array)

        # Zero-copy transfer using memoryview
        data_bytes = array.tobytes()
        hg.buffer_copy_from_bytes(
            self._executor.handle,
            self._handle,
            data_bytes
        )

    def to_numpy(self) -> np.ndarray:
        """
        Read buffer data to NumPy array (zero-copy when possible).

        Returns:
            NumPy array containing buffer data

        Raises:
            RuntimeError: If buffer has been freed
        """
        if self._freed:
            raise RuntimeError("Buffer has been freed")

        # Zero-copy read
        data_bytes = hg.buffer_to_bytes(
            self._executor.handle,
            self._handle
        )

        # Create NumPy array from bytes (zero-copy view)
        array = np.frombuffer(data_bytes, dtype=self._dtype)

        # Return a copy to avoid issues with buffer lifetime
        return array.copy()

    def from_bytes(self, data: bytes) -> None:
        """
        Copy data from raw bytes to buffer.

        Args:
            data: Raw bytes (must match buffer size)

        Raises:
            ValueError: If data size doesn't match buffer
            RuntimeError: If buffer has been freed
        """
        if self._freed:
            raise RuntimeError("Buffer has been freed")

        expected_bytes = self.nbytes
        if len(data) != expected_bytes:
            raise ValueError(
                f"Data size {len(data)} bytes doesn't match buffer size {expected_bytes} bytes"
            )

        hg.buffer_copy_from_bytes(
            self._executor.handle,
            self._handle,
            data
        )

    def to_bytes(self) -> bytes:
        """
        Read buffer data as raw bytes.

        Returns:
            Raw bytes containing buffer data

        Raises:
            RuntimeError: If buffer has been freed
        """
        if self._freed:
            raise RuntimeError("Buffer has been freed")

        return bytes(hg.buffer_to_bytes(
            self._executor.handle,
            self._handle
        ))

    def fill(self, value: float) -> None:
        """
        Fill buffer with a constant value.

        Args:
            value: Fill value

        Raises:
            RuntimeError: If buffer has been freed
        """
        if self._freed:
            raise RuntimeError("Buffer has been freed")

        hg.buffer_fill(
            self._executor.handle,
            self._handle,
            float(value),
            self._size
        )

    def copy_from(self, other: "Buffer") -> None:
        """
        Copy data from another buffer.

        Args:
            other: Source buffer (must have same size)

        Raises:
            ValueError: If buffer sizes don't match
            RuntimeError: If buffer has been freed
        """
        if self._freed or other._freed:
            raise RuntimeError("Buffer has been freed")

        if self._size != other._size:
            raise ValueError(
                f"Buffer sizes don't match: {self._size} != {other._size}"
            )

        hg.buffer_copy(
            self._executor.handle,
            other._handle,
            self._handle,
            self._size
        )

    def free(self) -> None:
        """
        Free buffer resources explicitly.

        Note:
            Normally not needed - use Executor context manager for automatic cleanup.
        """
        if not self._freed:
            hg.buffer_cleanup(self._handle)
            self._freed = True

    def __del__(self):
        """Cleanup on destruction."""
        if not self._freed:
            try:
                self.free()
            except:
                pass  # Ignore errors during cleanup

    def __repr__(self) -> str:
        """String representation."""
        status = "freed" if self._freed else "active"
        return (
            f"Buffer(handle={self._handle}, size={self._size}, "
            f"dtype={self._dtype}, status={status})"
        )
