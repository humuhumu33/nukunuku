"""
Operation wrappers for hologram compute.

Provides Pythonic wrappers around hologram-ffi operations with:
- Type checking and validation
- Automatic size inference
- Clear error messages
"""

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from .executor import Executor
    from .buffer import Buffer

# Import hologram_ffi (generated by UniFFI)
try:
    import hologram_ffi as hg
except ImportError:
    raise ImportError(
        "hologram_ffi not found. Please ensure the hologram-ffi library is built and available."
    )


# ==============================================================================
# Math Operations
# ==============================================================================

def vector_add(
    executor: "Executor",
    a: "Buffer",
    b: "Buffer",
    c: "Buffer",
    n: int = None
) -> None:
    """
    Element-wise addition: c = a + b

    Args:
        executor: Executor instance
        a: Input buffer A
        b: Input buffer B
        c: Output buffer C
        n: Number of elements (default: inferred from buffer size)

    Raises:
        ValueError: If buffer sizes don't match
    """
    if n is None:
        n = min(a.size, b.size, c.size)

    hg.vector_add_f32(executor.handle, a.handle, b.handle, c.handle, n)


def vector_sub(
    executor: "Executor",
    a: "Buffer",
    b: "Buffer",
    c: "Buffer",
    n: int = None
) -> None:
    """Element-wise subtraction: c = a - b"""
    if n is None:
        n = min(a.size, b.size, c.size)

    hg.vector_sub_f32(executor.handle, a.handle, b.handle, c.handle, n)


def vector_mul(
    executor: "Executor",
    a: "Buffer",
    b: "Buffer",
    c: "Buffer",
    n: int = None
) -> None:
    """Element-wise multiplication: c = a * b"""
    if n is None:
        n = min(a.size, b.size, c.size)

    hg.vector_mul_f32(executor.handle, a.handle, b.handle, c.handle, n)


def vector_div(
    executor: "Executor",
    a: "Buffer",
    b: "Buffer",
    c: "Buffer",
    n: int = None
) -> None:
    """Element-wise division: c = a / b"""
    if n is None:
        n = min(a.size, b.size, c.size)

    hg.vector_div_f32(executor.handle, a.handle, b.handle, c.handle, n)


def vector_min(
    executor: "Executor",
    a: "Buffer",
    b: "Buffer",
    c: "Buffer",
    n: int = None
) -> None:
    """Element-wise minimum: c = min(a, b)"""
    if n is None:
        n = min(a.size, b.size, c.size)

    hg.vector_min_f32(executor.handle, a.handle, b.handle, c.handle, n)


def vector_max(
    executor: "Executor",
    a: "Buffer",
    b: "Buffer",
    c: "Buffer",
    n: int = None
) -> None:
    """Element-wise maximum: c = max(a, b)"""
    if n is None:
        n = min(a.size, b.size, c.size)

    hg.vector_max_f32(executor.handle, a.handle, b.handle, c.handle, n)


def vector_abs(
    executor: "Executor",
    a: "Buffer",
    c: "Buffer",
    n: int = None
) -> None:
    """Element-wise absolute value: c = |a|"""
    if n is None:
        n = min(a.size, c.size)

    hg.vector_abs_f32(executor.handle, a.handle, c.handle, n)


def vector_neg(
    executor: "Executor",
    a: "Buffer",
    c: "Buffer",
    n: int = None
) -> None:
    """Element-wise negation: c = -a"""
    if n is None:
        n = min(a.size, c.size)

    hg.vector_neg_f32(executor.handle, a.handle, c.handle, n)


def vector_relu(
    executor: "Executor",
    a: "Buffer",
    c: "Buffer",
    n: int = None
) -> None:
    """Element-wise ReLU: c = max(0, a)"""
    if n is None:
        n = min(a.size, c.size)

    hg.vector_relu_f32(executor.handle, a.handle, c.handle, n)


def vector_clip(
    executor: "Executor",
    a: "Buffer",
    c: "Buffer",
    min_val: float,
    max_val: float,
    n: int = None
) -> None:
    """Clip values to range: c = clip(a, min_val, max_val)"""
    if n is None:
        n = min(a.size, c.size)

    hg.vector_clip_f32(executor.handle, a.handle, c.handle, n, min_val, max_val)


def scalar_add(
    executor: "Executor",
    a: "Buffer",
    c: "Buffer",
    scalar: float,
    n: int = None
) -> None:
    """Add scalar to vector: c = a + scalar"""
    if n is None:
        n = min(a.size, c.size)

    hg.scalar_add_f32(executor.handle, a.handle, c.handle, n, scalar)


def scalar_mul(
    executor: "Executor",
    a: "Buffer",
    c: "Buffer",
    scalar: float,
    n: int = None
) -> None:
    """Multiply vector by scalar: c = a * scalar"""
    if n is None:
        n = min(a.size, c.size)

    hg.scalar_mul_f32(executor.handle, a.handle, c.handle, n, scalar)


# ==============================================================================
# Activation Functions
# ==============================================================================

def sigmoid(
    executor: "Executor",
    input: "Buffer",
    output: "Buffer",
    n: int = None
) -> None:
    """Sigmoid activation: output = 1 / (1 + exp(-input))"""
    if n is None:
        n = min(input.size, output.size)

    hg.sigmoid_f32(executor.handle, input.handle, output.handle, n)


def tanh(
    executor: "Executor",
    input: "Buffer",
    output: "Buffer",
    n: int = None
) -> None:
    """Hyperbolic tangent activation: output = tanh(input)"""
    if n is None:
        n = min(input.size, output.size)

    hg.tanh_f32(executor.handle, input.handle, output.handle, n)


def gelu(
    executor: "Executor",
    input: "Buffer",
    output: "Buffer",
    n: int = None
) -> None:
    """GELU activation"""
    if n is None:
        n = min(input.size, output.size)

    hg.gelu_f32(executor.handle, input.handle, output.handle, n)


def softmax(
    executor: "Executor",
    input: "Buffer",
    output: "Buffer",
    n: int = None
) -> None:
    """Softmax activation: output[i] = exp(input[i]) / sum(exp(input))"""
    if n is None:
        n = min(input.size, output.size)

    hg.softmax_f32(executor.handle, input.handle, output.handle, n)


# ==============================================================================
# Reduction Operations
# ==============================================================================

def reduce_sum(
    executor: "Executor",
    input: "Buffer",
    output: "Buffer",
    n: int = None
) -> float:
    """
    Sum reduction: sum(input)

    Args:
        executor: Executor instance
        input: Input buffer
        output: Output buffer (must have at least 3 elements for temporaries)
        n: Number of elements (default: input size)

    Returns:
        Sum of all elements
    """
    if n is None:
        n = input.size

    if output.size < 3:
        raise ValueError("Output buffer must have at least 3 elements for temporaries")

    return hg.reduce_sum_f32(executor.handle, input.handle, output.handle, n)


def reduce_min(
    executor: "Executor",
    input: "Buffer",
    output: "Buffer",
    n: int = None
) -> float:
    """Minimum reduction: min(input)"""
    if n is None:
        n = input.size

    if output.size < 3:
        raise ValueError("Output buffer must have at least 3 elements for temporaries")

    return hg.reduce_min_f32(executor.handle, input.handle, output.handle, n)


def reduce_max(
    executor: "Executor",
    input: "Buffer",
    output: "Buffer",
    n: int = None
) -> float:
    """Maximum reduction: max(input)"""
    if n is None:
        n = input.size

    if output.size < 3:
        raise ValueError("Output buffer must have at least 3 elements for temporaries")

    return hg.reduce_max_f32(executor.handle, input.handle, output.handle, n)


# ==============================================================================
# Loss Functions
# ==============================================================================

def mse_loss(
    executor: "Executor",
    pred: "Buffer",
    target: "Buffer",
    output: "Buffer",
    n: int = None
) -> float:
    """
    Mean Squared Error loss

    Args:
        executor: Executor instance
        pred: Predictions buffer
        target: Targets buffer
        output: Output buffer (must have at least 3 elements for temporaries)
        n: Number of elements (default: min of buffer sizes)

    Returns:
        MSE loss value
    """
    if n is None:
        n = min(pred.size, target.size)

    if output.size < 3:
        raise ValueError("Output buffer must have at least 3 elements for temporaries")

    return hg.mse_loss_f32(executor.handle, pred.handle, target.handle, output.handle, n)


def cross_entropy_loss(
    executor: "Executor",
    pred: "Buffer",
    target: "Buffer",
    output: "Buffer",
    n: int = None
) -> float:
    """Cross Entropy loss"""
    if n is None:
        n = min(pred.size, target.size)

    if output.size < 3:
        raise ValueError("Output buffer must have at least 3 elements for temporaries")

    return hg.cross_entropy_loss_f32(
        executor.handle, pred.handle, target.handle, output.handle, n
    )


def binary_cross_entropy_loss(
    executor: "Executor",
    pred: "Buffer",
    target: "Buffer",
    output: "Buffer",
    n: int = None
) -> float:
    """Binary Cross Entropy loss"""
    if n is None:
        n = min(pred.size, target.size)

    if output.size < 3:
        raise ValueError("Output buffer must have at least 3 elements for temporaries")

    return hg.binary_cross_entropy_loss_f32(
        executor.handle, pred.handle, target.handle, output.handle, n
    )


# ==============================================================================
# Linear Algebra
# ==============================================================================

def gemm(
    executor: "Executor",
    a: "Buffer",
    b: "Buffer",
    c: "Buffer",
    m: int,
    n: int,
    k: int
) -> None:
    """
    General Matrix Multiplication: C = A * B

    Args:
        executor: Executor instance
        a: Matrix A (m×k)
        b: Matrix B (k×n)
        c: Matrix C (m×n)
        m: Number of rows in A and C
        n: Number of columns in B and C
        k: Number of columns in A and rows in B
    """
    hg.gemm_f32(executor.handle, a.handle, b.handle, c.handle, m, n, k)


def matvec(
    executor: "Executor",
    a: "Buffer",
    x: "Buffer",
    y: "Buffer",
    m: int,
    n: int
) -> None:
    """
    Matrix-Vector Multiplication: y = A * x

    Args:
        executor: Executor instance
        a: Matrix A (m×n)
        x: Vector x (n elements)
        y: Vector y (m elements)
        m: Number of rows in A
        n: Number of columns in A
    """
    hg.matvec_f32(executor.handle, a.handle, x.handle, y.handle, m, n)


# Convenience exports
__all__ = [
    # Math operations
    "vector_add",
    "vector_sub",
    "vector_mul",
    "vector_div",
    "vector_min",
    "vector_max",
    "vector_abs",
    "vector_neg",
    "vector_relu",
    "vector_clip",
    "scalar_add",
    "scalar_mul",
    # Activations
    "sigmoid",
    "tanh",
    "gelu",
    "softmax",
    # Reductions
    "reduce_sum",
    "reduce_min",
    "reduce_max",
    # Loss functions
    "mse_loss",
    "cross_entropy_loss",
    "binary_cross_entropy_loss",
    # Linear algebra
    "gemm",
    "matvec",
]
