//! Build script for hologram-core
//!
//! This script generates precompiled ISA programs from Python kernel schemas:
//!
//! Pipeline:
//! 1. Python schemas ‚Üí JSON (via hologram-codegen/build.rs)
//! 2. JSON ‚Üí ISA Programs (this script)
//!    - Simple operations: Direct JSON ‚Üí ISA translation
//!    - Complex operations: JSON ‚Üí Sigmatics ‚Üí ISA with canonicalization
//! 3. Generate const Rust code with embedded Programs
//!
//! Output: OUT_DIR/precompiled_ops.rs

use hologram_backends::isa::{Instruction, Program};
use hologram_backends::json_to_isa::{translate_json_to_isa, JsonSchema};
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

fn main() {
    println!("cargo:rerun-if-changed=../../target/json");
    println!("cargo:rerun-if-changed=build.rs");

    let json_dir = PathBuf::from("../../target/json");
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let out_path = Path::new(&out_dir).join("precompiled_ops.rs");

    // Check if JSON directory exists
    if !json_dir.exists() {
        println!("cargo:warning=‚ö†Ô∏è  JSON directory not found: {:?}", json_dir);
        println!("cargo:warning=‚ö†Ô∏è  Run 'cargo build -p hologram-codegen' first to generate JSON schemas");

        // Create empty file to avoid compilation errors
        fs::write(&out_path, "// No precompiled operations available\n").expect("Failed to write placeholder file");
        return;
    }

    println!("cargo:warning=üî® Generating precompiled ISA programs from JSON schemas...");

    let mut generated_code = String::from(
        "// Auto-generated precompiled ISA programs\n\
         // DO NOT EDIT - Generated by hologram-core/build.rs\n\
         #![allow(dead_code)]\n\n\
         use hologram_backends::{{Program, Instruction, Register, Type, Address}};\n\
         use std::collections::HashMap;\n\n",
    );

    let mut total_programs = 0;
    let mut simple_ops = 0;
    let mut complex_ops = 0;
    let mut total_original_ops = 0;
    let mut total_canonical_ops = 0;

    // Read all JSON files
    let json_files = match fs::read_dir(&json_dir) {
        Ok(entries) => entries
            .filter_map(|e| e.ok())
            .map(|e| e.path())
            .filter(|p| p.extension().is_some_and(|ext| ext == "json"))
            .collect::<Vec<_>>(),
        Err(e) => {
            println!("cargo:warning=‚ùå Failed to read JSON directory: {}", e);
            fs::write(&out_path, "// No precompiled operations available\n").expect("Failed to write placeholder file");
            return;
        }
    };

    if json_files.is_empty() {
        println!("cargo:warning=‚ö†Ô∏è  No JSON files found in {:?}", json_dir);
        fs::write(&out_path, "// No precompiled operations available\n").expect("Failed to write placeholder file");
        return;
    }

    for json_path in json_files {
        let kernel_name = json_path
            .file_stem()
            .and_then(|s| s.to_str())
            .expect("Invalid file name");

        // println!("cargo:warning=  Processing: {}.json", kernel_name);

        // Read JSON file
        let json_content = match fs::read_to_string(&json_path) {
            Ok(content) => content,
            Err(e) => {
                println!("cargo:warning=    ‚ùå Failed to read {}: {}", kernel_name, e);
                continue;
            }
        };

        // Parse JSON schema
        // Handle both single schemas and arrays of schemas (from Python compiler)
        let schema: JsonSchema = match serde_json::from_str::<Vec<JsonSchema>>(&json_content) {
            Ok(schemas) => {
                // Array of schemas - take the last one (main kernel)
                schemas
                    .into_iter()
                    .last()
                    .unwrap_or_else(|| panic!("Empty schema array in {}", kernel_name))
            }
            Err(_) => {
                // Try parsing as single schema
                match serde_json::from_str::<JsonSchema>(&json_content) {
                    Ok(schema) => schema,
                    Err(e) => {
                        println!("cargo:warning=    ‚ùå Failed to parse {}: {}", kernel_name, e);
                        continue;
                    }
                }
            }
        };

        // Classify operation type
        let op_type = classify_operation_from_name(&schema.kernel.name);

        // Translate to ISA Program
        let (program_const, is_complex, orig_ops, canon_ops) =
            match translate_and_generate(kernel_name, &schema, op_type) {
                Ok(result) => result,
                Err(e) => {
                    println!("cargo:warning=    ‚ùå Translation failed for {}: {}", kernel_name, e);
                    continue;
                }
            };

        generated_code.push_str(&program_const);
        generated_code.push('\n');

        total_programs += 1;
        if is_complex {
            complex_ops += 1;
        } else {
            simple_ops += 1;
        }
        total_original_ops += orig_ops;
        total_canonical_ops += canon_ops;

        // println!(
        //     "cargo:warning=    ‚úÖ Generated: {} ({})",
        //     kernel_name.to_uppercase(),
        //     op_type
        // );
    }

    // Write generated code
    fs::write(&out_path, generated_code).expect("Failed to write generated code");

    // Print summary
    println!("cargo:warning=");
    println!("cargo:warning=üìä Precompilation Summary:");
    println!("cargo:warning=   Total programs: {}", total_programs);
    println!("cargo:warning=   Simple ops (JSON‚ÜíISA): {}", simple_ops);
    println!("cargo:warning=   Complex ops (Sigmatics‚ÜíISA): {}", complex_ops);

    if total_original_ops > 0 {
        let reduction_pct = ((total_original_ops - total_canonical_ops) as f32 / total_original_ops as f32) * 100.0;
        println!(
            "cargo:warning=   Operation reduction: {:.1}% ({} ‚Üí {})",
            reduction_pct, total_original_ops, total_canonical_ops
        );
    }

    println!("cargo:warning=   Output: {:?}", out_path);
    println!("cargo:warning=‚úÖ Precompilation complete!");
}

/// Classify operation type from kernel name
fn classify_operation_from_name(kernel_name: &str) -> &'static str {
    let name_lower = kernel_name.to_lowercase();

    // Binary element-wise operations
    if name_lower.contains("add")
        || name_lower.contains("sub")
        || name_lower.contains("mul")
        || name_lower.contains("div")
    {
        return "binary_elementwise";
    }

    // Unary element-wise operations
    if name_lower.contains("relu")
        || name_lower.contains("sigmoid")
        || name_lower.contains("tanh")
        || name_lower.contains("exp")
        || name_lower.contains("log")
        || name_lower.contains("sin")
        || name_lower.contains("cos")
        || name_lower.contains("abs")
        || name_lower.contains("neg")
    {
        return "unary_elementwise";
    }

    // Reduction operations
    if name_lower.contains("sum")
        || name_lower.contains("dot")
        || name_lower.contains("max")
        || name_lower.contains("min")
    {
        return "reduction";
    }

    // Matrix operations
    if name_lower.contains("gemm") || name_lower.contains("gemv") || name_lower.contains("matmul") {
        return "matrix_op";
    }

    "complex"
}

/// Translate JSON to ISA Program and generate const Rust code
///
/// Returns: (generated_code, is_complex, original_ops, canonical_ops)
fn translate_and_generate(
    kernel_name: &str,
    schema: &JsonSchema,
    op_type: &str,
) -> Result<(String, bool, usize, usize), String> {
    let const_name = kernel_name.to_uppercase();
    let is_complex = op_type == "complex" || op_type == "matrix_op";

    // For simple operations, use direct JSON ‚Üí ISA translation
    // For complex operations, we'll add sigmatics integration later
    let program = if !is_complex {
        // Direct translation for simple operations
        translate_json_to_isa(schema)?
    } else {
        // For now, return placeholder for complex ops
        // TODO: Integrate sigmatics_to_isa for complex operations
        return Ok((
            format!(
                "/// Precompiled ISA program for {} operation\n\
                 /// Type: {} (PLACEHOLDER - TODO: implement translation)\n\
                 /// Generated from: {}.json\n\
                 pub const {}: Program = Program {{\n\
                 \x20   instructions: vec![Instruction::EXIT],\n\
                 \x20   labels: HashMap::new(),\n\
                 }};\n",
                kernel_name, op_type, kernel_name, const_name
            ),
            true,
            1,
            1,
        ));
    };

    // Serialize Program to Rust const code
    let program_code = serialize_program(&const_name, kernel_name, op_type, &program);

    // Count operations for metrics
    let ops_count = program.instructions.len();

    Ok((program_code, is_complex, ops_count, ops_count))
}

/// Serialize a Program into const Rust code
fn serialize_program(const_name: &str, kernel_name: &str, op_type: &str, program: &Program) -> String {
    let mut code = format!(
        "/// Precompiled ISA program for {} operation\n\
         /// Type: {}\n\
         /// Generated from: {}.json\n\
         /// Instructions: {}\n\
         pub const {}: Program = Program {{\n",
        kernel_name,
        op_type,
        kernel_name,
        program.instructions.len(),
        const_name
    );

    // Serialize instructions
    code.push_str("    instructions: vec![\n");
    for instr in &program.instructions {
        code.push_str(&format!("        {},\n", serialize_instruction(instr)));
    }
    code.push_str("    ],\n");

    // Serialize labels (using const HashMap construction)
    if program.labels.is_empty() {
        code.push_str("    labels: HashMap::new(),\n");
    } else {
        code.push_str("    labels: {\n");
        code.push_str("        let mut map = HashMap::new();\n");
        for (label, index) in &program.labels {
            code.push_str(&format!("        map.insert(\"{}\".to_string(), {});\n", label, index));
        }
        code.push_str("        map\n");
        code.push_str("    },\n");
    }

    code.push_str("};\n");
    code
}

/// Serialize an Instruction into Rust code
fn serialize_instruction(instr: &Instruction) -> String {
    match instr {
        Instruction::EXIT => "Instruction::EXIT".to_string(),

        Instruction::MOV_IMM { ty, dst, value } => format!(
            "Instruction::MOV_IMM {{ ty: {}, dst: Register({}), value: {} }}",
            serialize_type(ty),
            dst.0,
            value
        ),

        Instruction::MOV { ty, dst, src } => format!(
            "Instruction::MOV {{ ty: {}, dst: Register({}), src: Register({}) }}",
            serialize_type(ty),
            dst.0,
            src.0
        ),

        Instruction::LDG { ty, dst, addr } => format!(
            "Instruction::LDG {{ ty: {}, dst: Register({}), addr: {} }}",
            serialize_type(ty),
            dst.0,
            serialize_address(addr)
        ),

        Instruction::STG { ty, src, addr } => format!(
            "Instruction::STG {{ ty: {}, src: Register({}), addr: {} }}",
            serialize_type(ty),
            src.0,
            serialize_address(addr)
        ),

        Instruction::ADD { ty, dst, src1, src2 } => format!(
            "Instruction::ADD {{ ty: {}, dst: Register({}), src1: Register({}), src2: Register({}) }}",
            serialize_type(ty),
            dst.0,
            src1.0,
            src2.0
        ),

        Instruction::SUB { ty, dst, src1, src2 } => format!(
            "Instruction::SUB {{ ty: {}, dst: Register({}), src1: Register({}), src2: Register({}) }}",
            serialize_type(ty),
            dst.0,
            src1.0,
            src2.0
        ),

        Instruction::MUL { ty, dst, src1, src2 } => format!(
            "Instruction::MUL {{ ty: {}, dst: Register({}), src1: Register({}), src2: Register({}) }}",
            serialize_type(ty),
            dst.0,
            src1.0,
            src2.0
        ),

        Instruction::DIV { ty, dst, src1, src2 } => format!(
            "Instruction::DIV {{ ty: {}, dst: Register({}), src1: Register({}), src2: Register({}) }}",
            serialize_type(ty),
            dst.0,
            src1.0,
            src2.0
        ),

        Instruction::SHL { ty, dst, src, amount } => format!(
            "Instruction::SHL {{ ty: {}, dst: Register({}), src: Register({}), amount: Register({}) }}",
            serialize_type(ty),
            dst.0,
            src.0,
            amount.0
        ),

        Instruction::ABS { ty, dst, src } => format!(
            "Instruction::ABS {{ ty: {}, dst: Register({}), src: Register({}) }}",
            serialize_type(ty),
            dst.0,
            src.0
        ),

        Instruction::NEG { ty, dst, src } => format!(
            "Instruction::NEG {{ ty: {}, dst: Register({}), src: Register({}) }}",
            serialize_type(ty),
            dst.0,
            src.0
        ),

        Instruction::EXP { ty, dst, src } => format!(
            "Instruction::EXP {{ ty: {}, dst: Register({}), src: Register({}) }}",
            serialize_type(ty),
            dst.0,
            src.0
        ),

        Instruction::LOG { ty, dst, src } => format!(
            "Instruction::LOG {{ ty: {}, dst: Register({}), src: Register({}) }}",
            serialize_type(ty),
            dst.0,
            src.0
        ),

        Instruction::SIN { ty, dst, src } => format!(
            "Instruction::SIN {{ ty: {}, dst: Register({}), src: Register({}) }}",
            serialize_type(ty),
            dst.0,
            src.0
        ),

        Instruction::COS { ty, dst, src } => format!(
            "Instruction::COS {{ ty: {}, dst: Register({}), src: Register({}) }}",
            serialize_type(ty),
            dst.0,
            src.0
        ),

        Instruction::SIGMOID { ty, dst, src } => format!(
            "Instruction::SIGMOID {{ ty: {}, dst: Register({}), src: Register({}) }}",
            serialize_type(ty),
            dst.0,
            src.0
        ),

        Instruction::TANH { ty, dst, src } => format!(
            "Instruction::TANH {{ ty: {}, dst: Register({}), src: Register({}) }}",
            serialize_type(ty),
            dst.0,
            src.0
        ),

        _ => format!("/* Unsupported instruction: {:?} */ Instruction::EXIT", instr),
    }
}

/// Serialize a Type
fn serialize_type(ty: &hologram_backends::isa::Type) -> &'static str {
    use hologram_backends::isa::Type;
    match ty {
        Type::I8 => "Type::I8",
        Type::I16 => "Type::I16",
        Type::I32 => "Type::I32",
        Type::I64 => "Type::I64",
        Type::U8 => "Type::U8",
        Type::U16 => "Type::U16",
        Type::U32 => "Type::U32",
        Type::U64 => "Type::U64",
        Type::F16 => "Type::F16",
        Type::BF16 => "Type::BF16",
        Type::F32 => "Type::F32",
        Type::F64 => "Type::F64",
    }
}

/// Serialize an Address
fn serialize_address(addr: &hologram_backends::isa::Address) -> String {
    use hologram_backends::isa::Address;
    match addr {
        Address::BufferOffset { handle, offset } => {
            format!("Address::BufferOffset {{ handle: {}, offset: {} }}", handle, offset)
        }
        Address::PhiCoordinate { class, page, byte } => {
            format!(
                "Address::PhiCoordinate {{ class: {}, page: {}, byte: {} }}",
                class, page, byte
            )
        }
        Address::RegisterIndirect { base, offset } => {
            format!(
                "Address::RegisterIndirect {{ base: Register({}), offset: {} }}",
                base.0, offset
            )
        }
        Address::RegisterIndirectComputed { handle_reg, offset_reg } => format!(
            "Address::RegisterIndirectComputed {{ handle_reg: Register({}), offset_reg: Register({}) }}",
            handle_reg.0, offset_reg.0
        ),
    }
}
